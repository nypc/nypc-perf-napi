/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * Represents the outcome of battles between two players.
 *
 * This struct holds the battle statistics between players `i` and `j`,
 * including the number of wins each player achieved against the other.
 *
 * # Fields
 *
 * * `i` - Index of the first player (0-based)
 * * `j` - Index of the second player (0-based)
 * * `wij` - Number of wins by player `i` against player `j`
 * * `wji` - Number of wins by player `j` against player `i`
 *
 * # Example
 *
 * ```javascript
 * // Player 0 won 3 times against Player 1, Player 1 won 1 time against Player 0
 * const battle = new BattleResult({
 *   i: 0,
 *   j: 1,
 *   wij: 3.0,
 *   wji: 1.0,
 * });
 * ```
 */
export interface BattleResult {
  i: number
  j: number
  wij: number
  wji: number
}

/**
 * Configuration options for the performance calculation algorithm.
 *
 * These options control the behavior of the Newton-Raphson iteration
 * used to find maximum likelihood estimates of player performances.
 *
 * # Fields
 *
 * * `max_iterations` - Maximum number of iterations before giving up (default: 100)
 * * `epsilon` - Convergence threshold - algorithm stops when error < epsilon (default: 1e-6)
 *
 * # Example
 *
 * ```javascript
 * const options = new CalcOptions({
 *   max_iterations: 200,  // Allow more iterations for difficult cases
 *   epsilon: 1e-8        // Require higher precision
 * });
 * ```
 */
export interface CalcOptions {
  maxIterations?: number
  epsilon?: number
}

/**
 * Calculates player performance ratings using the Bradley-Terry model.
 *
 * This function implements a Newton-Raphson algorithm to find maximum
 * likelihood estimates of player performance levels based on head-to-head
 * battle outcomes. The algorithm iteratively adjusts ratings to best
 * explain the observed win/loss patterns.
 *
 * # Parameters
 *
 * * `ratings` - Initial performance ratings for all players. At least one
 *               rating should be fixed to serve as an anchor point.
 * * `battles` - Battle outcomes between players. Each battle specifies
 *               two players and their win counts against each other.
 * * `options` - Algorithm configuration including iteration limits and
 *               convergence criteria.
 *
 * # Returns
 *
 * A `CalcResult` object containing:
 * - Updated performance ratings
 * - Number of iterations if converged
 * - Final error if convergence failed
 *
 * # Algorithm Details
 *
 * The Bradley-Terry model estimates P(i beats j) = exp(π_i) / (exp(π_i) + exp(π_j))
 * where π_i and π_j are log-performance ratings. The algorithm finds ratings
 * that maximize the likelihood of the observed battle outcomes.
 *
 * # Example
 *
 * ```javascript
 * import { calc_perf, BattleResult, Rating, CalcOptions } from 'nypc-perf-wasm';
 *
 * const ratings = [
 *   new Rating({ fixed: false, value: 0.0 }),
 *   new Rating({ fixed: false, value: 0.0 }),
 *   new Rating({ fixed: true, value: 0.0 })  // Anchor
 * ];
 *
 * const battles = [
 *   new BattleResult({ i: 0, j: 1, wij: 2.0, wji: 1.0 }),
 *   new BattleResult({ i: 0, j: 2, wij: 1.0, wji: 0.0 })
 * ];
 *
 * const options = new CalcOptions({ max_iterations: 100, epsilon: 1e-6 });
 * const result = calc_perf(ratings, battles, options);
 *
 * if (result.iterations !== null) {
 *   console.log(`Converged in ${result.iterations} iterations`);
 *   console.log('Updated ratings:', result.ratings);
 * }
 * ```
 */
export declare function calcPerf(ratings: Array<Rating>, battles: Array<BattleResult>, options?: CalcOptions | undefined | null): CalcResult

/**
 * Result of a performance calculation.
 *
 * Contains the updated ratings and information about the algorithm's
 * convergence behavior. If the algorithm converged successfully,
 * `iterations` will contain the number of iterations required.
 * If it failed to converge, `error` will contain the final error value.
 *
 * # Fields
 *
 * * `ratings` - Updated performance ratings for all players
 * * `iterations` - Number of iterations if converged, null otherwise
 * * `error` - Final error value if did not converge, null otherwise
 */
export interface CalcResult {
  ratings: Array<number>
  iterations?: number
  error?: number
}

/**
 * Represents a player's performance rating.
 *
 * Each rating consists of a numerical value (on a log-scale) and a flag
 * indicating whether the rating should remain fixed during calculation.
 * Fixed ratings are typically used for anchor players to establish a
 * reference point in the rating system.
 *
 * # Fields
 *
 * * `fixed` - Whether this rating should remain constant during calculation
 * * `value` - The performance rating value (log-scale, higher = better)
 *
 * # Example
 *
 * ```javascript
 * // Variable rating that can be updated
 * const playerRating = new Rating({ fixed: false, value: 0.0 });
 *
 * // Fixed anchor rating
 * const anchorRating = new Rating({ fixed: true, value: 0.0 });
 * ```
 */
export interface Rating {
  fixed: boolean
  value: number
}
